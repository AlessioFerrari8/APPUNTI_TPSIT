https://reqres.in/

## Reqres
Reqres è un servizio API RESTful di esempio che fornisce dati fittizi per testare e prototipare applicazioni web. È comunemente utilizzato dagli sviluppatori per simulare chiamate API senza dover creare un backend reale.

## Promises
Avevamo visto un approccio alle Promises con le callback, un approccio alle operazioni asincrone che però portava a quello che viene chiamato "callback hell", ovvero una nidificazione eccessiva di callback che rende il codice difficile da leggere e mantenere.

---

## Programmazione Asincrona - La Strategia di Non Aspettare

### Concetto Fondamentale: Operazioni Non Bloccanti

La programmazione asincrona è un modello di programmazione specifico progettato per gestire compiti senza rimanere bloccati in attesa. È una tecnica che consente a un programma di avviare un'operazione lunga e, invece di pausarsi e aspettare che finisca, passare immediatamente ad altro lavoro. Questo è noto come **esecuzione non bloccante**. Quando l'operazione iniziale infine si completa, notifica il programma, spesso fornendo un risultato o attivando un'azione successiva.

#### L'Analogia della Riparazione dell'Auto

Questo illustra perfettamente il concetto. Un approccio sincrono sarebbe come portare l'auto in riparazione e sedersi in sala d'attesa finché non è finita. Sei bloccato dall'fare altre cose. L'approccio asincrono è come portare l'auto e dare il tuo numero di telefono al meccanico. Ora sei libero di andare a fare commissioni, fare la spesa o fare altre cose produttive. Quando l'auto è pronta, il meccanico ti chiama (la notifica), e puoi tornare indietro per affrontare l'attività completata.

### Il Caso d'Uso Ideale: Lavoro I/O-Bound

La programmazione asincrona è la soluzione ideale per compiti che sono I/O-bound. "I/O" sta per Input/Output e si riferisce a qualsiasi operazione in cui il programma comunica con il mondo esterno: leggere un file dal disco, effettuare una richiesta sulla rete o interrogare un database.

Una CPU è straordinariamente veloce, capace di eseguire milioni o miliardi di operazioni nel tempo che impiega una singola richiesta di rete per viaggiare a un server e tornare indietro. In un modello sincrono, la potente CPU è costretta a stare completamente inattiva durante questo periodo di attesa, sprecando prezioso tempo di elaborazione. La programmazione asincrona recupera questo tempo sprecato. Non bloccando, consente alla CPU di continuare a eseguire altri compiti mentre l'operazione I/O lenta procede in background.

### Meccanismi di Asincronia

I programmatori usano diversi modelli per gestire operazioni asincrone:

- **Callback**: Questo è un approccio iniziale in cui passi una funzione (la callback) all'operazione asincrona. L'istruzione è essenzialmente: "Avvia questo compito, e quando hai finito, esegui questa funzione che ti ho dato".

- **Promises o Futures**: Un'operazione asincrona può restituire un oggetto speciale, chiamato Promise o Future, che funge da segnaposto per il risultato che sarà eventualmente disponibile. Il resto del programma può mantenere questo segnaposto e controllare il suo stato o allegare codice da eseguire al suo completamento.

- **Async/Await**: Molti linguaggi di programmazione moderni forniscono le parole chiave async e await. Questa sintassi consente agli sviluppatori di scrivere codice asincrono che legge quasi come codice semplice e sequenziale, rendendo molto più facile gestire flussi di lavoro complessi e non bloccanti.

### Parte 6: La Grande Sintesi - Come Funziona Tutto Insieme

#### Asincronia come Modello di Concorrenza

La programmazione asincrona non è un concetto che esiste separatamente dalla concorrenza. Piuttosto, è una delle strategie principali per ottenere la concorrenza. La concorrenza è l'obiettivo generale: gestire più compiti in periodi di tempo sovrapposti. L'asincronia è uno strumento specifico e altamente efficiente per raggiungere questo obiettivo, specialmente in un singolo thread.

Molti sistemi notoriamente concorrenti, come quelli costruiti con Node.js, sono single-threaded. Raggiungono alti livelli di concorrenza senza multi-threading tradizionale utilizzando un "event loop". Questo loop controlla costantemente le operazioni I/O che si sono completate e quindi esegue il codice che era in attesa di quel risultato. Questa è una forma di context switching cooperativo molto efficiente per carichi di lavoro I/O-bound perché evita l'overhead del sistema operativo associato alla gestione di più thread.

#### Un Framework per la Comprensione: La Tabella Comparativa

Le sottili relazioni tra questi tre concetti possono essere chiarite mettendoli uno accanto all'altro:

| Criterio | Concorrenza | Parallelismo | Programmazione Asincrona |
|----------|-------------|--------------|--------------------------|
| Idea Centrale | Affrontare molte cose contemporaneamente. | Fare molte cose contemporaneamente. | Non aspettare operazioni lente. |
| Obiettivo Principale | Reattività, gestione della complessità. | Prestazioni grezze, alto throughput. | Efficienza CPU, reattività. |
| Meccanismo Chiave | Context switching, interleaving dei compiti. | Esecuzione simultanea su più core. | Chiamate non bloccanti, event loop, callback. |
| Analogia | Un giocoliere; un cassiere per due file. | Più chef; due cassieri per due file. | Portare l'auto in riparazione e ricevere una chiamata dopo. |
| Hardware | Un singolo core è sufficiente. | Più core sono necessari. | Un singolo core è sufficiente. |
| Migliore Per... | Applicazioni ad alto uso di UI o I/O-bound. | Compiti CPU-bound, computazionalmente pesanti. | Compiti I/O-bound (rete, accesso al disco). |
| Relazione | Il problema generale di gestire più compiti. | Un mezzo per eseguire più velocemente un programma concorrente. | Un modello di programmazione per ottenere concorrenza in modo efficiente. |