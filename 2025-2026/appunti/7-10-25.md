# 🌀 Event Loop, Web API e Code (Task/Microtask)

## 1. 🧠 Il Runtime JavaScript e il Single Threading

Il **runtime JavaScript** è formato da diversi componenti che lavorano insieme per permettere l’esecuzione del codice, in particolare dei **task asincroni** in modo **non bloccante**.

### 🔩 Componenti principali

- **JavaScript Engine**
  - Contiene:
    - **Call Stack** (Stack delle chiamate)
    - **Heap di Memoria**
- **Web API** – Interfacce fornite dal browser
- **Task Queue** (o **Callback Queue**)
- **Microtask Queue**
- **Event Loop**

> 🧵 JavaScript è *single-threaded*: utilizza un solo **Call Stack**.

---

### 📚 Il Call Stack

Il **Call Stack** gestisce l’esecuzione del programma:

1. Quando si invoca una funzione → viene creato un **contesto di esecuzione** e spinto nello stack.  
2. Una volta terminata → viene **rimossa (popped off)**.

---

### ⚠️ Il Problema del Blocco (Blocking)

Poiché JavaScript può gestire **solo un task alla volta**, un’operazione lunga (es. calcolo pesante) **blocca l’intero programma**.  
Per evitare che tutto si congeli, si usano **meccanismi asincroni**.

---

## 2. 🌐 Web API e Task Asincroni

Le **Web API** (es. `DOM`, `fetch`, `setTimeout`, sensori, fotocamera, geolocalizzazione, ecc.) forniscono **interfacce del browser** che permettono di eseguire operazioni in background.

> In questo modo il browser gestisce i task lunghi **senza bloccare il Call Stack**.

---

### ⚙️ Tipi di API Asincrone

1. **Callback-based** → Basate su callback  
2. **Promise-based** → Basate su promise

---

### 🔁 A. API Callback-Based e la Task Queue

Esempi: `setTimeout`, `geolocation.getCurrentPosition`.

#### 🔄 Flusso di Esecuzione (es. Geolocation)

1. L’invocazione dell’API viene aggiunta al **Call Stack** solo per **registrare** i callback (successo/errore).  
2. Il browser esegue il task in **background**.  
3. Al completamento, il callback viene spostato nella **Task Queue**, non direttamente nello stack.  
4. Quando lo stack è vuoto, l’**Event Loop** lo spinge sullo stack per l’esecuzione.

---

### ⏱️ Il Ritardo (Timer)

Con `setTimeout`:

- La funzione viene aggiunta al Call Stack **solo** per registrare callback e tempo di attesa.  
- Il tempo (`100ms`, ad esempio) è il **minimo** prima che il callback venga messo nella **Task Queue**.  
- Se il Call Stack è occupato, il callback **aspetta** ancora → il tempo reale sarà **> 100ms**.

---

## 3. ⚡ Le Promises e la Microtask Queue

Quando si lavora con le **Promises**, si utilizza la **Microtask Queue**.

---

### 📥 Microtask Queue

Coda speciale ad **alta priorità** che contiene:

- Callback di `.then`, `.catch`, `.finally`
- Esecuzione del corpo di una funzione dopo `await`
- Callback di `queueMicrotask()`
- Callback di `MutationObserver`

---

### 📬 Flusso di Esecuzione (es. `fetch`)

1. **Chiamata:** `fetch()` viene eseguita → crea una promise (stato `pending`) e avvia la richiesta di rete in background.  
2. **Registrazione:** `.then()` crea un *record di reazione* per la promise.  
3. **Completamento:** quando la risposta arriva → la promise diventa `fulfilled` o `rejected`, e il relativo handler viene spinto nella **Microtask Queue**.

---

### 🚨 Priorità della Microtask Queue

L’**Event Loop** dà priorità assoluta alla **Microtask Queue** rispetto alla **Task Queue**.

#### 🧩 Meccanismo di Priorità

1. Quando il **Call Stack** è vuoto → controlla la **Microtask Queue**.  
2. Esegue **tutti i microtask** in sequenza.  
3. Solo dopo → passa alla **Task Queue**.  
4. Dopo **ogni task**, ricontrolla subito la **Microtask Queue**.

---

### 🔁 Rischio: Loop Infinito di Microtask

Un microtask può crearne un altro.  
Se questo accade in un ciclo infinito → l’Event Loop **rimane bloccato** sulla Microtask Queue, congelando il programma.

---

## 4. 🔄 L’Event Loop e l’Ordine di Esecuzione

L’**Event Loop** controlla continuamente se il **Call Stack** è vuoto e sposta i task dalle code allo stack.

---

### 🧭 Ordine di Esecuzione

Quando lo stack è libero:

1. **Task Sincroni** → eseguiti subito sul Call Stack  
2. **Microtasks** → (Promises, `await`, `queueMicrotask`)  
3. **Tasks** → (Callback di `setTimeout`, Event Handlers)

---

### 🧮 Esempio di Ordinamento

Output tipo: **(5, 1, 3, 4, 2)**

#### Spiegazione:

- Una **Promise** risolta con `.then()` → callback spinto **subito** nella Microtask Queue.  
- Un **setTimeout** → callback nella **Task Queue**, solo dopo il timer.  
- Il **codice sincrono** → sempre per primo.

> 🔹 Ordine finale:  
> **Codice sincrono → Microtasks (svuotati tutti) → Tasks (callback/eventi)**

---

### ✨ In Sintesi

| Tipo di Task | Coda | Priorità | Esempi |
|---------------|------|-----------|---------|
| Sincroni | Call Stack | 🥇 Massima | codice normale |
| Microtasks | Microtask Queue | 🥈 Alta | Promise, await, queueMicrotask |
| Tasks | Task Queue | 🥉 Bassa | setTimeout, event listener |

---

> 💡 **Ricorda:**  
> L’Event Loop è il “direttore d’orchestra” che coordina Call Stack, Web API, Microtask e Task Queue per mantenere il codice JavaScript **reattivo e non bloccante**.

---