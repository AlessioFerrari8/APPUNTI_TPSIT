# ğŸŒ€ Event Loop, Web API e Code (Task/Microtask)

## 1. ğŸ§  Il Runtime JavaScript e il Single Threading

Il **runtime JavaScript** Ã¨ formato da diversi componenti che lavorano insieme per permettere lâ€™esecuzione del codice, in particolare dei **task asincroni** in modo **non bloccante**.

### ğŸ”© Componenti principali

- **JavaScript Engine**
  - Contiene:
    - **Call Stack** (Stack delle chiamate)
    - **Heap di Memoria**
- **Web API** â€“ Interfacce fornite dal browser
- **Task Queue** (o **Callback Queue**)
- **Microtask Queue**
- **Event Loop**

> ğŸ§µ JavaScript Ã¨ *single-threaded*: utilizza un solo **Call Stack**.

---

### ğŸ“š Il Call Stack

Il **Call Stack** gestisce lâ€™esecuzione del programma:

1. Quando si invoca una funzione â†’ viene creato un **contesto di esecuzione** e spinto nello stack.  
2. Una volta terminata â†’ viene **rimossa (popped off)**.

---

### âš ï¸ Il Problema del Blocco (Blocking)

PoichÃ© JavaScript puÃ² gestire **solo un task alla volta**, unâ€™operazione lunga (es. calcolo pesante) **blocca lâ€™intero programma**.  
Per evitare che tutto si congeli, si usano **meccanismi asincroni**.

---

## 2. ğŸŒ Web API e Task Asincroni

Le **Web API** (es. `DOM`, `fetch`, `setTimeout`, sensori, fotocamera, geolocalizzazione, ecc.) forniscono **interfacce del browser** che permettono di eseguire operazioni in background.

> In questo modo il browser gestisce i task lunghi **senza bloccare il Call Stack**.

---

### âš™ï¸ Tipi di API Asincrone

1. **Callback-based** â†’ Basate su callback  
2. **Promise-based** â†’ Basate su promise

---

### ğŸ” A. API Callback-Based e la Task Queue

Esempi: `setTimeout`, `geolocation.getCurrentPosition`.

#### ğŸ”„ Flusso di Esecuzione (es. Geolocation)

1. Lâ€™invocazione dellâ€™API viene aggiunta al **Call Stack** solo per **registrare** i callback (successo/errore).  
2. Il browser esegue il task in **background**.  
3. Al completamento, il callback viene spostato nella **Task Queue**, non direttamente nello stack.  
4. Quando lo stack Ã¨ vuoto, lâ€™**Event Loop** lo spinge sullo stack per lâ€™esecuzione.

---

### â±ï¸ Il Ritardo (Timer)

Con `setTimeout`:

- La funzione viene aggiunta al Call Stack **solo** per registrare callback e tempo di attesa.  
- Il tempo (`100ms`, ad esempio) Ã¨ il **minimo** prima che il callback venga messo nella **Task Queue**.  
- Se il Call Stack Ã¨ occupato, il callback **aspetta** ancora â†’ il tempo reale sarÃ  **> 100ms**.

---

## 3. âš¡ Le Promises e la Microtask Queue

Quando si lavora con le **Promises**, si utilizza la **Microtask Queue**.

---

### ğŸ“¥ Microtask Queue

Coda speciale ad **alta prioritÃ ** che contiene:

- Callback di `.then`, `.catch`, `.finally`
- Esecuzione del corpo di una funzione dopo `await`
- Callback di `queueMicrotask()`
- Callback di `MutationObserver`

---

### ğŸ“¬ Flusso di Esecuzione (es. `fetch`)

1. **Chiamata:** `fetch()` viene eseguita â†’ crea una promise (stato `pending`) e avvia la richiesta di rete in background.  
2. **Registrazione:** `.then()` crea un *record di reazione* per la promise.  
3. **Completamento:** quando la risposta arriva â†’ la promise diventa `fulfilled` o `rejected`, e il relativo handler viene spinto nella **Microtask Queue**.

---

### ğŸš¨ PrioritÃ  della Microtask Queue

Lâ€™**Event Loop** dÃ  prioritÃ  assoluta alla **Microtask Queue** rispetto alla **Task Queue**.

#### ğŸ§© Meccanismo di PrioritÃ 

1. Quando il **Call Stack** Ã¨ vuoto â†’ controlla la **Microtask Queue**.  
2. Esegue **tutti i microtask** in sequenza.  
3. Solo dopo â†’ passa alla **Task Queue**.  
4. Dopo **ogni task**, ricontrolla subito la **Microtask Queue**.

---

### ğŸ” Rischio: Loop Infinito di Microtask

Un microtask puÃ² crearne un altro.  
Se questo accade in un ciclo infinito â†’ lâ€™Event Loop **rimane bloccato** sulla Microtask Queue, congelando il programma.

---

## 4. ğŸ”„ Lâ€™Event Loop e lâ€™Ordine di Esecuzione

Lâ€™**Event Loop** controlla continuamente se il **Call Stack** Ã¨ vuoto e sposta i task dalle code allo stack.

---

### ğŸ§­ Ordine di Esecuzione

Quando lo stack Ã¨ libero:

1. **Task Sincroni** â†’ eseguiti subito sul Call Stack  
2. **Microtasks** â†’ (Promises, `await`, `queueMicrotask`)  
3. **Tasks** â†’ (Callback di `setTimeout`, Event Handlers)

---

### ğŸ§® Esempio di Ordinamento

Output tipo: **(5, 1, 3, 4, 2)**

#### Spiegazione:

- Una **Promise** risolta con `.then()` â†’ callback spinto **subito** nella Microtask Queue.  
- Un **setTimeout** â†’ callback nella **Task Queue**, solo dopo il timer.  
- Il **codice sincrono** â†’ sempre per primo.

> ğŸ”¹ Ordine finale:  
> **Codice sincrono â†’ Microtasks (svuotati tutti) â†’ Tasks (callback/eventi)**

---

### âœ¨ In Sintesi

| Tipo di Task | Coda | PrioritÃ  | Esempi |
|---------------|------|-----------|---------|
| Sincroni | Call Stack | ğŸ¥‡ Massima | codice normale |
| Microtasks | Microtask Queue | ğŸ¥ˆ Alta | Promise, await, queueMicrotask |
| Tasks | Task Queue | ğŸ¥‰ Bassa | setTimeout, event listener |

---

> ğŸ’¡ **Ricorda:**  
> Lâ€™Event Loop Ã¨ il â€œdirettore dâ€™orchestraâ€ che coordina Call Stack, Web API, Microtask e Task Queue per mantenere il codice JavaScript **reattivo e non bloccante**.

---