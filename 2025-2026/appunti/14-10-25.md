# üìò Appunti del 14 Ottobre 2025

## üóì Interrogati per Marted√¨ 21 Ottobre
- Azzetti  
- Gjergji  
- Esposito  
- Pittui  
- Brajha  

---

## ‚ö° Promises in JavaScript

Le **Promises** sono un concetto fondamentale in **JavaScript** per gestire **operazioni asincrone**, come:
- richieste HTTP verso un server (es. `fetch()`),
- lettura/scrittura di file,
- timer (`setTimeout`, `setInterval`),
- operazioni complesse che richiedono tempo.

Una **Promise** rappresenta **un valore che non √® ancora disponibile**, ma che lo sar√† **in futuro** (oppure fallir√†).

---

### üß© Stati di una Promise

Ogni Promise pu√≤ trovarsi in **uno di tre stati**:

| Stato | Significato |
|-------|--------------|
| **Pending** | La Promise √® in corso, non ha ancora prodotto un risultato. |
| **Fulfilled** | L'operazione √® completata con successo e la Promise restituisce un valore. |
| **Rejected** | L'operazione √® fallita e la Promise restituisce un motivo (errore). |

---

### üí° Sintassi di base

```javascript
const myPromise = new Promise((resolve, reject) => {
  const success = true; // Simula un'operazione

  if (success) {
    resolve("Operazione completata!");
  } else {
    reject("Errore durante l'operazione.");
  }
});

// Consumo della Promise
myPromise
  .then((result) => {
    console.log(result); // "Operazione completata!"
  })
  .catch((error) => {
    console.error(error); // "Errore durante l'operazione."
  });

```

üïê Esempio pratico: simulare una richiesta asincrona
```javascript
function fetchData() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      const success = true;
      if (success) {
        const data = { id: 1, name: "Mario" };
        resolve(data);
      } else {
        reject("Impossibile recuperare i dati.");
      }
    }, 1000);
  });
}

fetchData()
  .then((data) => {
    console.log("‚úÖ Dati ricevuti:", data);
  })
  .catch((error) => {
    console.error("‚ùå Errore:", error);
  });
```

üîÅ Metodi delle Promises

### `.then()`
Esegue una funzione quando la Promise viene risolta (fulfilled).
```javascript
myPromise.then((value) => console.log(value));
```

### `.catch()`
Esegue una funzione se la Promise viene rifiutata (rejected).
```javascript
myPromise.catch((error) => console.error(error));
```

### `.finally()`
Viene eseguito sempre, indipendentemente dal risultato.
```javascript
myPromise
  .then((value) => console.log(value))
  .catch((error) => console.error(error))
  .finally(() => console.log("Operazione terminata."));
```

üß† Promise Chaining
√à possibile collegare pi√π operazioni asincrone una dopo l'altra con il chaining.
```javascript
fetchData()
  .then((data) => {
    console.log("Dati ricevuti:", data);
    return data.name;
  })
  .then((name) => {
    console.log("Nome:", name);
  })
  .catch((error) => {
    console.error("Errore:", error);
  });
```

‚öôÔ∏è Metodi Statici delle Promises

### `Promise.all()`
Esegue pi√π Promises in parallelo e le risolve tutte insieme.
```javascript
const p1 = Promise.resolve("Uno");
const p2 = Promise.resolve("Due");
const p3 = Promise.resolve("Tre");

Promise.all([p1, p2, p3])
  .then((values) => console.log(values)) // ["Uno", "Due", "Tre"]
  .catch((error) => console.error(error));
```
‚ö†Ô∏è Se una sola Promise fallisce, `Promise.all()` va in rejected.

### `Promise.allSettled()`
Simile a `Promise.all()`, ma non fallisce se una delle Promises viene rifiutata. Restituisce lo stato di ognuna.
```javascript
const p1 = Promise.resolve("OK");
const p2 = Promise.reject("Errore");

Promise.allSettled([p1, p2]).then((results) => console.log(results));
```

### `Promise.race()`
Restituisce il risultato della prima Promise che si risolve o viene rifiutata.
```javascript
const p1 = new Promise((res) => setTimeout(res, 100, "Primo"));
const p2 = new Promise((res) => setTimeout(res, 200, "Secondo"));

Promise.race([p1, p2]).then((value) => console.log(value)); // "Primo"
```

### `Promise.any()`
Restituisce la prima Promise risolta (ignora le rifiutate finch√© almeno una va a buon fine).
```javascript
const p1 = Promise.reject("Errore");
const p2 = Promise.resolve("Successo!");

Promise.any([p1, p2]).then((value) => console.log(value)); // "Successo!"
```

‚è≥ Promises e Async/Await
`async` e `await` sono una sintassi pi√π leggibile per lavorare con le Promises.
```javascript
async function getUser() {
  try {
    const data = await fetchData();
    console.log("Utente:", data);
  } catch (error) {
    console.error("Errore:", error);
  } finally {
    console.log("Operazione completata.");
  }
}

getUser();
```
Nota: `await` pu√≤ essere usato solo dentro una funzione `async` e fa "aspettare" JavaScript finch√© la Promise non viene risolta o rifiutata.

üß© Riepilogo Visuale

| Metodo            | Quando si usa           | Cosa fa                               |
| :---------------- | :---------------------- | :------------------------------------ |
| `then()`          | Dopo il successo        | Esegue il codice con il risultato     |
| `catch()`         | Dopo un errore          | Gestisce gli errori                   |
| `finally()`       | Sempre                  | Esegue codice finale                  |
| `Promise.all()`   | Tutte devono riuscire   | Restituisce un array di risultati     |
| `Promise.allSettled()` | Tutte vengono valutate  | Restituisce stato e valore di ognuna  |
| `Promise.race()`  | Vince la pi√π veloce     | Restituisce la prima completata       |
| `Promise.any()`   | Vince la prima risolta  | Ignora le rifiutate                   |

üßæ Scheda Riassuntiva

### Concetto Base
Le Promises gestiscono operazioni asincrone in JavaScript, permettendo di lavorare con risultati che non sono immediatamente disponibili.

### Stati Possibili
*   `Pending` ‚Üí in attesa di risultato
*   `Fulfilled` ‚Üí completata con successo
*   `Rejected` ‚Üí fallita con errore

### Metodi Principali
*   `.then()` ‚Üí gestisce il risultato positivo
*   `.catch()` ‚Üí gestisce l'errore
*   `.finally()` ‚Üí viene eseguito sempre

### Metodi Statici
*   `Promise.all()` ‚Üí risolve tutte insieme (fallisce se una fallisce)
*   `Promise.allSettled()` ‚Üí mostra il risultato di tutte, anche se alcune falliscono
*   `Promise.race()` ‚Üí restituisce la pi√π veloce
*   `Promise.any()` ‚Üí restituisce la prima risolta

### Async/Await
*   `async` ‚Üí dichiara una funzione asincrona
*   `await` ‚Üí attende che una Promise si risolva
*   Consente di scrivere codice asincrono in modo pi√π leggibile

---

## üìö Guida Approfondita ad Async/Await in JavaScript

### üéØ Introduzione: Scrivere Codice Asincrono Semplice

Per gestire le operazioni asincrone, il JavaScript moderno si √® evoluto molto. Inizialmente, si usavano le **callback annidate**, una tecnica che poteva portare a codice difficile da gestire, noto come **"callback hell"** o **"piramide del terrore"** (pyramid of doom).

Le **Promise** hanno rappresentato un enorme passo avanti, permettendo di "appiattire" quella piramide con catene di chiamate `.then()`. Sebbene molto pi√π leggibile delle callback annidate, anche questa tecnica pu√≤ diventare verbosa quando si devono eseguire molte operazioni in sequenza.

Per risolvere definitivamente questo problema, JavaScript ha introdotto **async/await**: una sintassi speciale e moderna costruita sopra le Promise. Non le sostituisce, ma agisce come **"zucchero sintattico"**, permettendoci di scrivere codice asincrono che appare e si comporta in modo molto simile al codice sincrono, migliorandone drasticamente la leggibilit√†.

---

### 1Ô∏è‚É£ La Keyword `async`: La Garanzia di una Promise

La prima parola chiave da capire √® `async`. La sua regola principale √® semplice ma potente.

#### üìå La Regola Fondamentale di `async`

Posizionare la parola chiave `async` prima di una dichiarazione di funzione ha un effetto molto specifico: **assicura che la funzione restituisca sempre una promise**.

Se la funzione restituisce un valore non-promise, `async` lo avvolger√† automaticamente in una promise risolta.

```javascript
async function f() {
  return 1;
}

f().then(alert); // Mostra 1
```

#### üîÑ Rafforzare il Concetto

Per essere ancora pi√π chiari, √® anche possibile restituire esplicitamente una promise da una funzione async. Il risultato finale √® esattamente lo stesso:

```javascript
async function f() {
  return Promise.resolve(1);
}

f().then(alert); // Mostra 1
```

---

### 2Ô∏è‚É£ La Keyword `await`: Mettere in Pausa l'Esecuzione

La parola chiave `await` √® il complemento di `async`. Funziona esclusivamente all'interno delle funzioni async per gestire le promise.

#### üìå La Funzione Principale di `await`

Il suo scopo primario √® semplice: **`await` mette in pausa la funzione async** in cui si trova, in attesa che la promise termini (cio√® che venga risolta o rigettata). Una volta che la promise √® "settled", `await` fa due cose:
- Se la promise √® rigettata, **lancia un errore**
- Altrimenti, **restituisce il suo risultato**

#### ‚ö†Ô∏è La Regola Critica: Solo Dentro `async`

**La keyword `await` funziona solo all'interno di una funzione `async`**. Se si tenta di usarla in una funzione normale, si otterr√† un errore di sintassi.

#### üîç Illustrare la "Pausa"

L'esempio seguente dimostra chiaramente come `await` metta in pausa la funzione:

```javascript
async function f() {
  let promise = new Promise((resolve, reject) => {
    setTimeout(() => resolve("fatto!"), 1000)
  });

  let result = await promise; // L'esecuzione di f() si ferma qui per 1 secondo

  alert(result); // "fatto!"
}

f();
```

**‚ö° Importante**: `await` non blocca l'intero programma come farebbe una funzione `sleep()` in altri linguaggi. Invece, mette in pausa solo la funzione async stessa e cede il controllo al **"event loop"** di JavaScript. Questo permette al browser di rimanere reattivo e di gestire altri compiti, come eventi dell'interfaccia utente o altre operazioni in background.

---

### 3Ô∏è‚É£ Caso Pratico: La Trasformazione di `showAvatar()`

Vediamo un esempio pratico per apprezzare appieno la potenza di async/await. La nostra funzione `showAvatar()` ha l'obiettivo di eseguire una sequenza di attivit√† asincrone:

1. Recuperare i dati di un utente da un file JSON locale
2. Utilizzare quei dati per recuperare un profilo utente dall'API di GitHub
3. Mostrare l'avatar dell'utente

#### ‚ú® Il Codice Rifattorizzato

Ecco la versione pulita e rifattorizzata della funzione `showAvatar()` che utilizza async/await:

```javascript
async function showAvatar() {
  // leggi il nostro JSON
  let response = await fetch('/article/promise-chaining/user.json');
  let user = await response.json();

  // leggi l'utente da GitHub
  let githubResponse = await fetch(`https://api.github.com/users/${user.name}`);
  let githubUser = await githubResponse.json();

  // mostra l'avatar
  let img = document.createElement('img');
  img.src = githubUser.avatar_url;
  img.className = "promise-avatar-example";
  document.body.append(img);

  // attendi 3 secondi
  await new Promise(resolve => setTimeout(resolve, 3000));

  img.remove();

  return githubUser;
}

showAvatar();
```

#### üéñÔ∏è Il Vantaggio Principale

Il vantaggio pi√π importante √® la sua **incredibile leggibilit√†**. Il codice non solo funziona, ma racconta una storia chiara, passo dopo passo. Si legge come un normale codice sincrono, eseguito dall'alto verso il basso, senza callback o catene di `.then()`. Questa √® la leggibilit√† che cerchiamo e la vera "magia" di async/await.

---

### 4Ô∏è‚É£ Gestione degli Errori con `try...catch`

Una delle caratteristiche pi√π potenti di async/await √® come semplifica la gestione degli errori.

#### ‚ö†Ô∏è Comportamento in Caso di Errore

Se la promise su cui `await` √® in attesa viene rigettata, `await` **lancia un errore**, proprio come se ci fosse un'istruzione `throw new Error()` in quella riga.

#### üõ°Ô∏è La Soluzione: `try...catch`

Questo comportamento ci permette di gestire gli errori delle operazioni asincrone utilizzando la sintassi standard e familiare `try...catch`, che rappresenta un enorme vantaggio per la chiarezza del codice.

#### üí° Esempio Pratico

Nell'esempio seguente, avvolgiamo le chiamate `await` in un blocco `try...catch` per gestire potenziali fallimenti:

```javascript
async function fetchUser() {
  try {
    let response = await fetch('http://no-such-url');
    let user = await response.json(); // Questa riga non verr√† eseguita se fetch fallisce
  } catch(err) {
    // Cattura gli errori da qualsiasi `await` nel blocco `try`
    alert(err);
  }
}

fetchUser();
```

**‚úÖ Vantaggio**: Un singolo blocco `try...catch` pu√≤ gestire elegantemente errori provenienti da **molteplici chiamate `await` sequenziali**. Ad esempio, nel codice qui sopra, il `catch` intercetterebbe sia un fallimento della chiamata `fetch` sia un eventuale errore nel parsing del JSON con `.json()`. Questo √® molto pi√π pulito che dover aggiungere gestori `.catch()` separati a ogni passo di una catena di promise.

---

### 5Ô∏è‚É£ Riepilogo dei Concetti Chiave

#### üîë `async`
- ‚úÖ Fa in modo che una funzione restituisca **sempre una promise**
- ‚úÖ Permette di usare la keyword `await` al suo interno

#### ‚è∏Ô∏è `await`
- ‚úÖ Mette in pausa l'esecuzione della funzione fino a quando la promise non √® "settled" (risolta o rigettata)
- ‚úÖ Se la promise viene rigettata, **lancia un'eccezione**, che pu√≤ essere catturata con `try...catch`
- ‚úÖ Altrimenti, restituisce il **risultato della promise risolta**

#### üéØ Conclusione

Insieme, `async` e `await` forniscono un fantastico framework per scrivere codice JavaScript asincrono che √® **facile da leggere, scrivere e mantenere**.

---

### üìä Tabella Comparativa: Promise vs Async/Await

| Aspetto | Promise (`.then()`) | Async/Await |
|---------|---------------------|-------------|
| **Leggibilit√†** | Catene di `.then()` possono diventare complesse | Codice lineare, simile al sincrono |
| **Gestione Errori** | `.catch()` per ogni catena | Un singolo `try...catch` per tutto |
| **Debugging** | Stack trace pi√π complessi | Stack trace pi√π chiari |
| **Sintassi** | Callback e catene | Codice sequenziale |
| **Condizioni** | Complicate con `.then()` annidati | Facili con `if/else` normali |

